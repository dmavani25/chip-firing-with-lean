import Mathlib.Data.Finset.Basic
import Mathlib.Data.Finset.Fold
import Mathlib.Data.Multiset.Basic
import Mathlib.Data.Fintype.Basic
import Mathlib.Algebra.Group.Subgroup.Basic
import Mathlib.Tactic.Abel
-- import LeanCopilot

open Multiset Finset

-- Assume V is a finite type with decidable equality
variable {V : Type} [DecidableEq V] [Fintype V]

-- Multigraph with undirected and loopless edges
structure CFGraph (V : Type) [DecidableEq V] [Fintype V] :=
  (edges : Multiset (V × V))
  (loopless : ∀ e ∈ edges, e.fst ≠ e.snd)
  (undirected : ∀ e ∈ edges, (e.snd, e.fst) ∈ edges)

-- Divisor as a function from vertices to integers
def CFDiv (V : Type) := V → ℤ

-- Number of edges between two vertices
def num_edges (G : CFGraph V) (v w : V) : ℕ :=
  Multiset.card (G.edges.filter (λ e => e = (v, w) ∨ e = (w, v)))

-- Degree of a vertex
def degG (G : CFGraph V) (v : V) : ℤ :=
  Multiset.card (G.edges.filter (λ e => e.fst = v ∨ e.snd = v))

-- Firing move at a vertex
def firing_move (G : CFGraph V) (D : CFDiv V) (v : V) : CFDiv V :=
  λ w => if w = v then D v - degG G v else D w + num_edges G v w

-- Borrowing move at a vertex
def borrowing_move (G : CFGraph V) (D : CFDiv V) (v : V) : CFDiv V :=
  λ w => if w = v then D v + degG G v else D w - num_edges G v w

-- Define finset_sum using Finset.fold
def finset_sum {α β} [AddCommMonoid β] (s : Finset α) (f : α → β) : β :=
  s.fold (· + ·) 0 f

-- Update set_firing to use finset_sum
def set_firing (G : CFGraph V) (D : CFDiv V) (S : Finset V) : CFDiv V :=
  λ w => D w + finset_sum S (λ v => if w = v then - (degG G v) else num_edges G v w)

-- Lemma: Number of edges from a vertex to itself is zero (since the graph is loopless)
lemma num_edges_self_zero (G : CFGraph V) (v : V) : num_edges G v v = 0 := by
  unfold num_edges
  -- Simplify the filter predicate
  have h_filter : G.edges.filter (λ e => e = (v, v) ∨ e = (v, v)) = G.edges.filter (λ e => e = (v, v)) := by
    ext e
    simp only [or_self]
  rw [h_filter]
  -- We need to show that the cardinality of this filtered multiset is zero
  rw [Multiset.card_eq_zero]
  -- So we need to show that the filtered multiset is empty
  apply Multiset.filter_eq_nil.mpr
  -- For all e ∈ G.edges, e ≠ (v, v)
  intro e h_e_in_edges
  -- We need to show that e ≠ (v, v)
  -- Suppose for contradiction that e = (v, v)
  by_contra h
  -- Then e = (v, v)
  have h_e_eq : e = (v, v) := h
  -- But G.loopless says e.fst ≠ e.snd
  have h_loopless := G.loopless e h_e_in_edges
  -- Substitute e = (v, v) into h_loopless
  rw [h_e_eq] at h_loopless
  -- Then h_loopless becomes v ≠ v, which is false
  exact h_loopless rfl
  -- So we have a contradiction, and e ≠ (v, v)
  -- This completes the proof

-- Lemma: The sum over all vertices of num_edges G v w equals degG G w

-- Lemma: The sum over v ≠ w of num_edges G v w equals degG G w

-- Lemma: Performing set-firing from all vertices leaves the divisor unchanged

instance : AddGroup (CFDiv V) := Pi.addGroup

-- Define the principal divisors generated by firing moves at vertices
def principal_divisors (G : CFGraph V) : AddSubgroup (CFDiv V) :=
  AddSubgroup.closure (Set.range (λ v => λ w => if w = v then -degG G v else num_edges G v w))

-- Define linear equivalence of divisors
def linear_equiv (G : CFGraph V) (D D' : CFDiv V) : Prop :=
  D' - D ∈ principal_divisors G

-- Proposition: Linear equivalence is an equivalence relation on Div(G)
theorem linear_equiv_is_equivalence (G : CFGraph V) : Equivalence (linear_equiv G) := by
  apply Equivalence.mk
  -- Reflexivity
  {
    intro D
    unfold linear_equiv
    have h_zero : D - D = 0 := by simp
    rw [h_zero]
    exact AddSubgroup.zero_mem _
  }
  -- Symmetry
  {
    intros D D' h
    unfold linear_equiv at *
    have h_symm : D - D' = -(D' - D) := by simp [sub_eq_add_neg, neg_sub]
    rw [h_symm]
    exact AddSubgroup.neg_mem _ h
  }
  -- Transitivity
  {
    intros D D' D'' h1 h2
    unfold linear_equiv at *
    have h_trans : D'' - D = (D'' - D') + (D' - D) := by
      { -- Use the simp tactic to simplify the expression
        simp
      }
    rw [h_trans]
    exact AddSubgroup.add_mem _ h2 h1
  }
