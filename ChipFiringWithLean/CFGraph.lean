import Mathlib.Data.Finset.Basic
import Mathlib.Data.Finset.Fold
import Mathlib.Data.Multiset.Basic
import Mathlib.Algebra.Group.Subgroup.Basic
import Mathlib.Tactic.Abel
import Mathlib.LinearAlgebra.Matrix.GeneralLinearGroup.Defs

set_option linter.unusedVariables false
set_option trace.split.failure true

open Multiset Finset

-- Assume V is a finite type with decidable equality
variable {V : Type} [DecidableEq V] [Fintype V]

-- Multigraph with undirected and loopless edges
structure CFGraph (V : Type) [DecidableEq V] [Fintype V] :=
  (edges : Multiset (V × V))
  --(loopless : ∀ e ∈ edges, e.fst ≠ e.snd)
  --(undirected : ∀ e ∈ edges, (e.snd, e.fst) ∈ edges)

-- Divisor as a function from vertices to integers
def CFDiv (V : Type) := V → ℤ

-- Number of edges between two vertices as an integer
def num_edges (G : CFGraph V) (v w : V) : ℤ :=
  ↑(Multiset.card (G.edges.filter (λ e => e = (v, w) ∨ e = (w, v))))

-- Degree (Valence) of a vertex as an integer
def vertex_degree (G : CFGraph V) (v : V) : ℤ :=
  ↑(Multiset.card (G.edges.filter (λ e => e.fst = v ∨ e.snd = v)))

-- Firing move at a vertex
def firing_move (G : CFGraph V) (D : CFDiv V) (v : V) : CFDiv V :=
  λ w => if w = v then D v - vertex_degree G v else D w + num_edges G v w

-- Borrowing move at a vertex
def borrowing_move (G : CFGraph V) (D : CFDiv V) (v : V) : CFDiv V :=
  λ w => if w = v then D v + vertex_degree G v else D w - num_edges G v w

-- Define finset_sum using Finset.fold
def finset_sum {α β} [AddCommMonoid β] (s : Finset α) (f : α → β) : β :=
  s.fold (· + ·) 0 f

-- Define set_firing to use finset_sum with consistent types
def set_firing (G : CFGraph V) (D : CFDiv V) (S : Finset V) : CFDiv V :=
  λ w => D w + finset_sum S (λ v => if w = v then -vertex_degree G v else num_edges G v w)

instance : AddGroup (CFDiv V) := Pi.addGroup

-- Define the principal divisors generated by firing moves at vertices
def principal_divisors (G : CFGraph V) : AddSubgroup (CFDiv V) :=
  AddSubgroup.closure (Set.range (λ v => λ w => if w = v then -vertex_degree G v else num_edges G v w))

-- Define linear equivalence of divisors
def linear_equiv (G : CFGraph V) (D D' : CFDiv V) : Prop :=
  D' - D ∈ principal_divisors G

-- Proposition: Linear equivalence is an equivalence relation on Div(G)
theorem linear_equiv_is_equivalence (G : CFGraph V) : Equivalence (linear_equiv G) := by
  apply Equivalence.mk
  -- Reflexivity
  {
    intro D
    unfold linear_equiv
    have h_zero : D - D = 0 := by simp
    rw [h_zero]
    exact AddSubgroup.zero_mem _
  }
  -- Symmetry
  {
    intros D D' h
    unfold linear_equiv at *
    have h_symm : D - D' = -(D' - D) := by simp [sub_eq_add_neg, neg_sub]
    rw [h_symm]
    exact AddSubgroup.neg_mem _ h
  }
  -- Transitivity
  {
    intros D D' D'' h1 h2
    unfold linear_equiv at *
    have h_trans : D'' - D = (D'' - D') + (D' - D) := by
      { -- Use the simp tactic to simplify the expression
        simp
      }
    rw [h_trans]
    exact AddSubgroup.add_mem _ h2 h1
  }

-- Define divisor class determined by a divisor
def divisor_class (G : CFGraph V) (D : CFDiv V) : Set (CFDiv V) :=
  {D' : CFDiv V | linear_equiv G D D'}

-- Define effective divisors (in terms of non-negativity, returning a Bool)
def effective_bool (D : CFDiv V) : Bool :=
  ↑((Finset.univ.filter (fun v => D v < 0)).card = 0)

-- Define effective divisors (in terms of equivalent Prop)
def effective (D : CFDiv V) : Prop :=
  ∀ v : V, D v ≥ 0

-- Define the set of effective divisors
-- Note: We use the Prop returned by `effective` in set comprehension
def Div_plus (G : CFGraph V) : Set (CFDiv V) :=
  {D : CFDiv V | effective D}

-- Define winnable divisor
-- Note: We use the Prop returned by `linear_equiv` in set comprehension
def winnable (G : CFGraph V) (D : CFDiv V) : Prop :=
  ∃ D' ∈ Div_plus G, linear_equiv G D D'

-- Define a firing script as a function from vertices to integers
def firing_script (V : Type) := V → ℤ

-- Discrete Laplacian operator on G
-- TBD

-- Script-firing a divisor with a firing script
-- TBD

-- Define Laplacian matrix as an |V| x |V| integer matrix
open Matrix
variable [Fintype V]

def laplacian_matrix (G : CFGraph V) : Matrix V V ℤ :=
  λ i j => if i = j then vertex_degree G i else - (num_edges G i j)

-- Note: The Laplacian matrix L is given by Deg(G) - A, where Deg(G) is the diagonal matrix of degrees and A is the adjacency matrix.
-- This matrix can be used to represent the effect of a firing script on a divisor.

-- Apply the Laplacian matrix to a firing script to get a new divisor
def apply_laplacian (G : CFGraph V) (σ : firing_script V) : CFDiv V :=
  fun v => (laplacian_matrix G).mulVec σ v

-- Degree of a divisor
def deg (D : CFDiv V) : ℤ := ∑ v, D v

-- Define q-reduced divisors
def q_reduced (G : CFGraph V) (q : V) (D : CFDiv V) : Prop :=
  (∀ v ∈ {v | v ≠ q}, D v ≥ 0) ∧
  (∀ S ⊆ {v | v ≠ q}, S ≠ ∅ → ∃ v ∈ S, D v < vertex_degree G v - finset_sum (Finset.univ.filter (λ v' => v' ≠ v)) (λ w => num_edges G w v))

-- Define the ordering of divisors
def divisor_order (G : CFGraph V) (q : V) (D D' : CFDiv V) : Prop :=
  (∃ T : Finset V, T ⊆ (Finset.univ.filter (λ v => v ≠ q)) ∧ D' = set_firing G D T) ∧
  (∀ T' : Finset V, T' ⊆ (Finset.univ.filter (λ v => v ≠ q)) → D' ≠ set_firing G D T')

-- Define the ordering of divisors using the divisor_order relation
def divisor_ordering (G : CFGraph V) (q : V) (D D' : CFDiv V) : Prop :=
  divisor_order G q D' D

-- Legal set-firing: Ensure no vertex in S is in debt after firing
def legal_set_firing (G : CFGraph V) (D : CFDiv V) (S : Finset V) : Prop :=
  ∀ v ∈ S, set_firing G D S v ≥ 0

-- A configuration on a graph G with distinguished vertex q removed
structure Config (V : Type) (q : V) :=
  (vertex_degree : V → ℤ)
  (non_negative_except_q : ∀ v : V, v ≠ q → vertex_degree v ≥ 0)

-- Define degree of a configuration
def degree {q : V} (c : Config V q) : ℤ :=
  ∑ v in (univ.filter (λ v => v ≠ q)), c.vertex_degree v

-- Ordering on configurations: c ≥ c' if c(v) ≥ c'(v) for all v ∈ V
def config_ge {q : V} (c c' : Config V q) : Prop :=
  ∀ v : V, c.vertex_degree v ≥ c'.vertex_degree v

-- Non-negative configuration: c ≥ 0 if all values are non-negative
def config_nonnegative {q : V} (c : Config V q) : Prop :=
  ∀ v : V, c.vertex_degree v ≥ 0

-- Linear equivalence of configurations: c ∼ c' if they can be transformed by lending/borrowing
def config_linear_equiv {q : V} (G : CFGraph V) (c c' : Config V q) : Prop :=
  let diff := λ v => c'.vertex_degree v - c.vertex_degree v
  diff ∈ AddSubgroup.closure (Set.range (λ v => λ w => if w = v then -vertex_degree G v else num_edges G v w))

-- Superstable configuration: No legal non-empty set-firing exists
def superstable (G : CFGraph V) (q : V) (c : Config V q) : Prop :=
  ∀ S ⊆ (univ.filter (λ v => v ≠ q)), S ≠ ∅ → ∃ v ∈ S, set_firing G c.vertex_degree S v < c.vertex_degree v

-- Example: Construct a valid configuration
def example_config (q : V) : Config V q :=
  { vertex_degree := λ v => if v = q then -1 else 2,
    non_negative_except_q := λ v hv => by
      simp
      split_ifs with h
      contradiction
      exact zero_le_two }

-- Edge orientation structure assigns direction to each edge
structure Orientation (G : CFGraph V) :=
  (directed_edges : Multiset (V × V))
  (consistent : ∀ e ∈ G.edges, e ∈ directed_edges ∨ (e.snd, e.fst) ∈ directed_edges)

-- Reverse orientation swaps the direction of all edges
def reverse_orientation (G : CFGraph V) (O : Orientation G) : Orientation G :=
  ⟨O.directed_edges.map (λ e => (e.snd, e.fst)), λ e h => by
    cases O.consistent e h with
    | inl _ => exact Or.inr (Multiset.mem_map_of_mem _ ‹_›)
    | inr _ => exact Or.inl (Multiset.mem_map_of_mem _ ‹_›)⟩

-- Indegree and outdegree under a given orientation
def indeg (G : CFGraph V) (O : Orientation G) (v : V) : ℕ :=
  Multiset.card (O.directed_edges.filter (λ e => e.snd = v))

def outdeg (G : CFGraph V) (O : Orientation G) (v : V) : ℕ :=
  Multiset.card (O.directed_edges.filter (λ e => e.fst = v))

-- A vertex is a source if it has no incoming edges
def is_source (G : CFGraph V) (O : Orientation G) (v : V) : Prop :=
  indeg G O v = 0

-- A vertex is a sink if it has no outgoing edges
def is_sink (G : CFGraph V) (O : Orientation G) (v : V) : Prop :=
  outdeg G O v = 0

-- Define the divisor associated with an orientation
def divisor_of_orientation (G : CFGraph V) (O : Orientation G) : CFDiv V :=
  λ v => indeg G O v - 1

-- Define the canonical divisor of a graph
def canonical_divisor (G : CFGraph V) : CFDiv V :=
  λ v => (vertex_degree G v) - 2

-- Maximal unwinnable divisor: adding any vertex makes it winnable
def maximal_unwinnable (G : CFGraph V) (D : CFDiv V) : Prop :=
  ¬winnable G D ∧ ∀ v : V, winnable G (λ w => D w + if w = v then 1 else 0)

-- Genus of a graph, equivalent to the cycle rank
def genus (G : CFGraph V) : ℤ :=
  Multiset.card G.edges - Fintype.card V + 1
