import Mathlib.Data.Finset.Basic
import Mathlib.Data.Finset.Fold
import Mathlib.Data.Multiset.Basic
import Mathlib.Algebra.Group.Subgroup.Basic
import Mathlib.Tactic.Abel
import Mathlib.LinearAlgebra.Matrix.GeneralLinearGroup.Defs
import Mathlib.Algebra.BigOperators.Group.Finset
import ChipFiringWithLean.Basic
import Paperproof

set_option linter.unusedVariables false
set_option trace.split.failure true
set_option linter.unusedSectionVars false

open Multiset Finset

-- Assume V is a finite type with decidable equality
variable {V : Type} [DecidableEq V] [Fintype V]

/-- A configuration on a graph G with respect to a distinguished vertex q.
    Represents an element of ℤ(V\{q}) ⊆ ℤV with non-negativity constraints on V\{q}.

    Fields:
    * vertex_degree - Assignment of integers to vertices
    * non_negative_except_q - Proof that all values except at q are non-negative -/
structure Config (V : Type) (q : V) :=
  /-- Assignment of integers to vertices representing the number of chips at each vertex -/
  (vertex_degree : V → ℤ)
  /-- Proof that all vertices except q have non-negative values -/
  (non_negative_except_q : ∀ v : V, v ≠ q → vertex_degree v ≥ 0)

/-- The degree of a configuration is the sum of all values except at q.
    deg(c) = ∑_{v ∈ V\{q}} c(v) -/
def config_degree {q : V} (c : Config V q) : ℤ :=
  ∑ v in (univ.filter (λ v => v ≠ q)), c.vertex_degree v

/-- Ordering on configurations: c ≥ c' if c(v) ≥ c'(v) for all v ∈ V.
    This is a pointwise comparison of the number of chips at each vertex. -/
def config_ge {q : V} (c c' : Config V q) : Prop :=
  ∀ v : V, c.vertex_degree v ≥ c'.vertex_degree v

/-- A configuration is non-negative if all vertices (including q) have non-negative values.
    This is stronger than the basic Config constraint which only requires non-negativity on V\{q}. -/
def config_nonnegative {q : V} (c : Config V q) : Prop :=
  ∀ v : V, c.vertex_degree v ≥ 0

/-- Linear equivalence of configurations: c ∼ c' if they can be transformed into one another
    through a sequence of lending and borrowing operations. The difference between configurations
    must be in the subgroup generated by firing moves. -/
def config_linear_equiv {q : V} (G : CFGraph V) (c c' : Config V q) : Prop :=
  let diff := λ v => c'.vertex_degree v - c.vertex_degree v
  diff ∈ AddSubgroup.closure (Set.range (λ v => λ w => if w = v then -vertex_degree G v else num_edges G v w))

/-- A configuration is superstable if it has no legal nonempty set-firings.
    Equivalently, for all nonempty S ⊆ V \ {q}, there exists v ∈ S such that
    c(v) < outdeg_S(v), meaning firing S would make v negative. -/
def superstable (G : CFGraph V) (q : V) (c : Config V q) : Prop :=
  ∀ S ⊆ (univ.filter (λ v => v ≠ q)), S ≠ ∅ → ∃ v ∈ S, set_firing G c.vertex_degree S v < c.vertex_degree v

/-- Axiom defining that if a configuration c is superstable on graph G with sink vertex q,
    then the number of chips at q must be 0. This property follows from the general definition
    of superstability because: if q had any positive number of chips, then those chips could
    potentially be fired/redistributed, but superstable by definition have no legal firings possible.
-/
axiom superstable_zero_at_q (G : CFGraph V) (q : V) (c : Config V q) :
  superstable G q c → c.vertex_degree q = 0

/-- A maximal superstable configuration has no legal firings and dominates all other superstable configs -/
def maximal_superstable {q : V} (G : CFGraph V) (c : Config V q) : Prop :=
  superstable G q c ∧ ∀ c' : Config V q, superstable G q c' → config_ge c' c

/-- Axiom: Defining winnability of configurations through linear equivalence and chip addition.
    Used to show that adding a chip at any non-q vertex results in a winnable configuration
    when starting from a linearly equivalent divisor to a maximal superstable configuration. -/
axiom winnable_through_equiv_and_chip (G : CFGraph V) (q : V) (D : CFDiv V) (c : Config V q) :
  linear_equiv G D (λ v => c.vertex_degree v - if v = q then 1 else 0) →
  maximal_superstable G c →
  ∀ v : V, v ≠ q →
  winnable G (λ w => D w + if w = v then 1 else 0)

/-- Axiom: Defining a special case of winnability when adding a chip at the distinguished vertex q.
    Demonstrates that adding a chip at q to a divisor linearly equivalent to a maximal
    superstable configuration results in a winnable configuration. -/
axiom winnable_when_adding_at_q (G : CFGraph V) (q : V) (D : CFDiv V) (c : Config V q) :
  maximal_superstable G c →
  linear_equiv G D (λ v => c.vertex_degree v - if v = q then 1 else 0) →
  winnable G (λ w => D w + if w = q then 1 else 0)
